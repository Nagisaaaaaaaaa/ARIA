#pragma once

#include "ARIA/Mosaic.h"
#include "ARIA/Property.h"
#include "ARIA/Tup.h"

#include <thrust/detail/copy.h>

namespace ARIA {

namespace mosaic::detail {

// A `MosaicReference` is a proxy returned by dereferencing a `MosaicIterator`.
// Suppose `it` is a `MosaicIterator`, then `*it` will return a `MosaicReference`.
//
// Just like properties, several main features should be supported:
// 1. Can be implicitly cast to `T`.
// 2. Can be set by `T` or any other types which can be implicitly cast to `T`.
// 3. Operators should be automatically generated.
// 4. Can be handled by `Auto`.
//
// But we are unable to generate `MosaicReference`s with `ARIA_PROP` because:
// 1. The properties generated by `ARIA_PROP` are "non-owning".
//    They just obtain the references to the objects, not the objects themselves.
//    But `MosaicReference`s should be "owning".
//    They should obtain all the iterators to the storages.
// 2. It's still controversial about whether to
//    make properties generated by `ARIA_PROP` both copiable and movable.
//    But `MosaicReference`s should always be copiable.
//
// So, this implementation is something like a compromise:
// 1. Inherit from `PropertyBase`.
//    Automatically generate operators, satisfy `concept Property`, support `Auto`.
// 2. Some duplications of codes.
//    Similar to the implementation of `ARIA_PROP`.
template <typename TMosaic_, typename TReferences>
  requires(is_mosaic_v<TMosaic_>)
class MosaicReference final : public property::detail::PropertyBase<MosaicReference<TMosaic_, TReferences>> {
public:
  using TMosaic = TMosaic_;

private:
  static_assert(ValidMosaic<TMosaic>, "The mosaic definition is invalid");

  using T = typename is_mosaic<TMosaic>::T;
  using TMosaicPattern = typename is_mosaic<TMosaic>::TMosaicPattern;

  static constexpr size_t size = pfr::tuple_size_recursive_v<TMosaicPattern>;
  static_assert(size == thrust::tuple_size<TReferences>::value,
                "The iterator types are inconsistent with the mosaic pattern");

public:
  ARIA_HOST_DEVICE constexpr explicit MosaicReference(const TReferences &references) : references_(references) {
    ForEach<size>([&]<auto i>() {
      static_assert(
          std::is_same_v<std::decay_t<decltype(Auto(pfr::get_recursive<i>(std::declval<TMosaicPattern &>())))>,
                         std::decay_t<decltype(Auto(get<i>(references_)))>>,
          "The iterator types are inconsistent with the mosaic pattern");
    });
  }

  ARIA_COPY_MOVE_ABILITY(MosaicReference, default, default);

public:
  ARIA_HOST_DEVICE constexpr T value() const {
    TMosaicPattern mosaicPattern;
    ForEach<size>([&]<auto i>() { pfr::get_recursive<i>(mosaicPattern) = get<i>(references_); });
    return TMosaic{}(mosaicPattern);
  }

  ARIA_HOST_DEVICE constexpr operator T() const { return value(); }

  template <typename U>
  ARIA_HOST_DEVICE constexpr MosaicReference &operator=(U &&arg) {
    T value = std::forward<U>(arg);
    TMosaicPattern mosaicPattern = TMosaic{}(value);
    ForEach<size>([&]<auto i>() { get<i>(references_) = pfr::get_recursive<i>(mosaicPattern); });
    return *this;
  }

  template <typename U, size_t n>
  ARIA_HOST_DEVICE constexpr MosaicReference &operator=(const U (&args)[n]) {
    operator=(property::detail::ConstructWithArray<T>(args, std::make_index_sequence<n>{}));
    return *this;
  }

private:
  TReferences references_;
};

//
//
//
// Whether the given type is `MosaicReference<...>`.
template <typename T>
struct is_mosaic_reference : std::false_type {};

template <typename TMosaic, typename TReferences>
struct is_mosaic_reference<MosaicReference<TMosaic, TReferences>> : std::true_type {};

template <typename T>
constexpr bool is_mosaic_reference_v = is_mosaic_reference<T>::value;

//
//
//
//
//
//! We have to introduce our own `TransformIterator` here, because
//! 1. `boost::transform_iterator` cannot be used with GPU codes.
//! 2. `thrust::transform_iterator` performs on copies of the inputs, not references.
//
// It is implemented with brute force since maybe we will find a better library.
template <typename TMosaic_, typename TBase>
  requires(is_mosaic_v<TMosaic_>)
class TransformIterator final {
public:
  using TMosaic = TMosaic_;

private:
  static_assert(ValidMosaic<TMosaic>, "The mosaic definition is invalid");

public:
  ARIA_HOST_DEVICE constexpr TransformIterator() = default;

  ARIA_HOST_DEVICE constexpr explicit TransformIterator(const TBase &base) : base_(base) {}

  ARIA_COPY_MOVE_ABILITY(TransformIterator, default, default);

public:
  ARIA_HOST_DEVICE constexpr const TBase &base() const { return base_; }

  ARIA_HOST_DEVICE constexpr TBase &base() { return base_; }

public:
  // *it
  ARIA_HOST_DEVICE constexpr auto operator*() const {
    // Suppose `it` is a `MosaicIterator`, then `*it` will return a `MosaicReference`.
    using TReferences = decltype(*base());
    return MosaicReference<TMosaic, TReferences>{*base()};
  }

  ARIA_HOST_DEVICE constexpr auto operator*() {
    using TReferences = decltype(*base());
    return MosaicReference<TMosaic, TReferences>{*base()};
  }

  // ++it
  ARIA_HOST_DEVICE constexpr TransformIterator &operator++() {
    ++base();
    return *this;
  }

  // it++
  ARIA_HOST_DEVICE constexpr TransformIterator operator++(int) {
    TransformIterator tmp = *this;
    ++(*this);
    return tmp;
  }

  // --it
  ARIA_HOST_DEVICE constexpr TransformIterator &operator--() {
    --base();
    return *this;
  }

  // it--
  ARIA_HOST_DEVICE constexpr TransformIterator operator--(int) {
    TransformIterator tmp = *this;
    --(*this);
    return tmp;
  }

  // it + i
  ARIA_HOST_DEVICE friend constexpr TransformIterator operator+(const TransformIterator &lhs,
                                                                const std::ptrdiff_t &rhs) {
    return TransformIterator{lhs.base() + rhs};
  }

  // i + it
  ARIA_HOST_DEVICE friend constexpr TransformIterator operator+(const std::ptrdiff_t &lhs,
                                                                const TransformIterator &rhs) {
    return TransformIterator{lhs + rhs.base()};
  }

  // it - i
  ARIA_HOST_DEVICE friend constexpr TransformIterator operator-(const TransformIterator &lhs,
                                                                const std::ptrdiff_t &rhs) {
    return TransformIterator{lhs.base() - rhs};
  }

  // it0 - it1
  ARIA_HOST_DEVICE friend constexpr std::ptrdiff_t operator-(const TransformIterator &lhs,
                                                             const TransformIterator &rhs) {
    return lhs.base() - rhs.base();
  }

  // it[i]
  ARIA_HOST_DEVICE constexpr auto operator[](const std::ptrdiff_t &i) const { return *((*this) + i); }

  ARIA_HOST_DEVICE constexpr auto operator[](const std::ptrdiff_t &i) { return *((*this) + i); }

  // it0 == it1
  ARIA_HOST_DEVICE friend constexpr bool operator==(const TransformIterator &a, const TransformIterator &b) noexcept {
    return a.base() == b.base();
  }

  // it0 != it1
  ARIA_HOST_DEVICE friend constexpr bool operator!=(const TransformIterator &a, const TransformIterator &b) noexcept {
    return a.base() != b.base();
  }

private:
  TBase base_;
};

//
//
//
template <typename TMosaic, typename TBase>
ARIA_HOST_DEVICE constexpr auto make_transform_iterator(const TBase &base) {
  return TransformIterator<TMosaic, TBase>{base};
}

//
//
//
//
//
// \brief Generate a `MosaicIterator` with a tuple of iterators which
// are consistent with the mosaic pattern.
//
// \example ```cpp
// using T = Tup<int, float>;
// using TMosaic = Mosaic<T, MosaicPattern>;
//
// std::vector<int> is = {0, 1, 2, 3, 4};
// std::array<float, 5> fs = {0.1F, 1.2F, 2.3F, 3.4F, 4.5F};
//
// auto begin = Auto(make_mosaic_iterator<TMosaic>(Tup{is.begin(), fs.begin()}));
// *begin += T{10, 10.01F};
// T value = *begin; // The value will be `{10, 10.11F}`.
// ```
template <typename TMosaic, typename... TIterators> // For `Mosaic`, wrap the iterators with `thrust` and `boost`.
  requires(is_mosaic_v<TMosaic>)
ARIA_HOST_DEVICE static constexpr auto make_mosaic_iterator(const Tup<TIterators...> &iterators) {
  thrust::tuple<TIterators...> iteratorsThrust;
  ForEach<sizeof...(TIterators)>([&]<auto i>() { get<i>(iteratorsThrust) = get<i>(iterators); });

  return make_transform_iterator<TMosaic>(thrust::make_zip_iterator(iteratorsThrust));
}

template <typename TNonMosaic, typename TIterator> // For non-`Mosaic`, simply return the unique iterator.
  requires(!is_mosaic_v<TNonMosaic>)
ARIA_HOST_DEVICE static constexpr auto make_mosaic_iterator(const Tup<TIterator> &iterator) {
  return get<0>(iterator);
}

//
//
//
// "Pointers" can be regarded as a subset of "iterators".
template <typename T, typename... TPointers>
ARIA_HOST_DEVICE static constexpr auto make_mosaic_pointer(const Tup<TPointers...> &pointers) {
  return make_mosaic_iterator<T>(pointers);
}

//
//
//
// Concepts `MosaicIterator` and `MosaicPointer`.
template <typename T>
struct is_mosaic_iterator : std::false_type {};

template <typename T>
  requires(is_mosaic_reference_v<decltype(*std::declval<T>())>)
struct is_mosaic_iterator<T> : std::true_type {};

template <typename T>
constexpr bool is_mosaic_iterator_v = is_mosaic_iterator<T>::value;

template <typename T>
concept MosaicIterator = is_mosaic_iterator_v<T>;

template <typename T>
struct is_mosaic_pointer : is_mosaic_iterator<T> {}; // "Pointers" can be regarded as a subset of "iterators".

template <typename T>
constexpr bool is_mosaic_pointer_v = is_mosaic_pointer<T>::value;

template <typename T>
concept MosaicPointer = is_mosaic_pointer_v<T>;

//
//
//
//
//
template <typename... Ts>
consteval auto ThrustTuple2TupImpl(const thrust::tuple<Ts...> &) {
  using TArray = MakeTypeArray<Ts...>;
  return to_tup_t<TArray>{};
}

// Cast `thrust::tuple` to `Tup`.
template <typename TThrustTuple>
using thrust_tuple_2_tup_t = decltype(ThrustTuple2TupImpl(std::declval<TThrustTuple>()));

// Cast `MosaicIterator` to `Tup`.
template <MosaicIterator TMosaicIterator>
using mosaic_iterator_2_tup_t =
    thrust_tuple_2_tup_t<decltype(std::declval<TMosaicIterator>().base().get_iterator_tuple())>;

// Cast `MosaicPointer` to `Tup`.
template <MosaicPointer TMosaicPointer>
using mosaic_pointer_2_tup_t =
    thrust_tuple_2_tup_t<decltype(std::declval<TMosaicPointer>().base().get_iterator_tuple())>;

//
//
//
// Cast `thrust::tuple` to `Tup`.
template <typename TThrustTuple>
ARIA_HOST_DEVICE static constexpr auto ThrustTuple2Tup(const TThrustTuple &tupleThrust) {
  using TTup = thrust_tuple_2_tup_t<TThrustTuple>;

  TTup res;
  ForEach<rank_v<TTup>>([&]<auto i>() { get<i>(res) = get<i>(tupleThrust); });
  return res;
}

// Cast `MosaicIterator` to `Tup`.
template <MosaicIterator TMosaicIterator>
ARIA_HOST_DEVICE static constexpr auto MosaicIterator2Tup(const TMosaicIterator &iterator) {
  return ThrustTuple2Tup(iterator.base().get_iterator_tuple());
}

// Cast `MosaicPointer` to `Tup`.
template <MosaicPointer TMosaicPointer>
ARIA_HOST_DEVICE static constexpr auto MosaicPointer2Tup(const TMosaicPointer &pointer) {
  return ThrustTuple2Tup(pointer.base().get_iterator_tuple());
}

//
//
//
//
//
//! `copy` does the same thing as `thrust::copy` but is able to handle `MosaicIterator`s.
template <MosaicIterator TItIn, MosaicIterator TItOut>
ARIA_HOST_DEVICE TItOut copy(TItIn srcBegin, TItIn srcEnd, TItOut dst) {
  using TMosaic = typename decltype(*dst)::TMosaic;
  static_assert(std::is_same_v<typename decltype(*srcBegin)::TMosaic, TMosaic>,
                "Inconsistent mosaic definitions of mosaic iterators");

  auto srcBeginTup = Auto(MosaicIterator2Tup(srcBegin));
  auto srcEndTup = Auto(MosaicIterator2Tup(srcEnd));
  auto dstTup = Auto(MosaicIterator2Tup(dst));

  using TSrcTup = decltype(srcBeginTup);
  using TDstTup = decltype(dstTup);

  constexpr uint rank = rank_v<TDstTup>;
  static_assert(rank_v<TSrcTup> == rank, "Inconsistent ranks of mosaic iterators");

  TDstTup resTup;
  ForEach<rank>(
      [&]<auto i>() { get<i>(resTup) = thrust::copy(get<i>(srcBeginTup), get<i>(srcEndTup), get<i>(dstTup)); });

  return make_mosaic_iterator<TMosaic>(resTup);
}

template <typename TItIn, typename TItOut>
  requires(!MosaicIterator<TItIn> && !MosaicIterator<TItOut>)
ARIA_HOST_DEVICE TItOut copy(TItIn srcBegin, TItIn srcEnd, TItOut dst) {
  using T = decltype(Auto(*dst));
  return make_mosaic_iterator<T>(Tup{thrust::copy(srcBegin, srcEnd, dst)});
}

} // namespace mosaic::detail

} // namespace ARIA
