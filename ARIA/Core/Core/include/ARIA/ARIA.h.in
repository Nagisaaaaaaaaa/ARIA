#pragma once

/// \file
/// \warning "Higher beings, these words are for you alone.
/// Beyond this point you enter the land of ARIA.
/// Step across this threshold and obey our laws."

//
//
//
#include "ARIA/detail/Macros.h"

#include <cstddef>
#include <cstdint>

namespace ARIA {

/// \brief Always use `uint` instead of `unsigned`.
using uint = uint32_t;

/// \brief Always use `int64` instead of `int64_t`.
using int64 = int64_t;

/// \brief Always use `uint64` instead of `uint64_t`.
using uint64 = uint64_t;

static_assert(sizeof(int) == sizeof(uint), "Size of `int` and `uint` should be the same");
static_assert(sizeof(int64) == sizeof(uint64), "Size of `int64` and `uint64` should be the same");

/// \brief `Real` is a universal number type defined by cmake options.
using Real = ${aria_real_type};

/// \brief Use `100.0_R` to define a `Real` equals to one hundred.
ARIA_HOST_DEVICE constexpr Real operator"" _R(long double value) {
  return static_cast<Real>(value);
}

/// \brief Use `100_R` to define a `Real` equals to one hundred.
ARIA_HOST_DEVICE constexpr Real operator"" _R(unsigned long long value) {
  return static_cast<Real>(value);
}

/// \brief Overload the lambda functions.
///
/// \example ```cpp
/// std::visit(
///   Overload{[](auto arg) { std::cout << arg << std::endl; },
///            [](double arg) { std::cout << std::fixed << arg << std::endl; },
///            [](const std::string &arg) { std::cout << std::quoted(arg) << std::endl; }},
///   v);
/// ```
///
/// \details This implementation is based on https://en.cppreference.com/w/cpp/utility/variant/visit.
template <class... Ts>
struct Overload : Ts... {
  using Ts::operator()...;
};

template <class... Ts>
Overload(Ts...) -> Overload<Ts...>;

/// \brief A commonly-used policy, means whether the class is for host use.
struct SpaceHost {};

/// \brief A commonly-used policy, means whether the class is for device use.
struct SpaceDevice {};

} // namespace ARIA
